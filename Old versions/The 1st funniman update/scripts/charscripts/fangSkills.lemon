global bool Fang.bounce
global u8 Fang.coolDown

//# address-hook(0x006a76) end(0x006bd6)
function void InitializeGameCharacters()
{
	// Xtrachar 3 comp stats
	if (competition_mode.active)
	{
		EXS3_speedcap = 0x0600
		EXS3_acceleration = 0x0015
		EXS3_deceleration = 0x0200
	}
	
	if (XtraChar == 3)
	{
		Fang.bounce = false
		Fang.coolDown = 20
	}
	
	base.InitializeGameCharacters()
	return
}

//# address-hook(0x016444) end(0x016498)
function void Character.BaseUpdate.Knuckles()
{
	base.Character.BaseUpdate.Knuckles()
	if (XtraChar == 3)
	{
		++Fang.coolDown
		CheckCollisonForCorkGlobal()
		//shouldnt be a problem doing it like this, have it checking for collisons here and in each cork individually, but this is probably not a good way of doing this. 
	}
}

function void KnucklesPressedJumpInMidAir()
{
	if (!competition_mode.active && (XtraChar != 3 || char.character != CHARACTER_KNUCKLES) || (competition_mode.active && char.character != 5))
	{
		base.KnucklesPressedJumpInMidAir()
		return
	}
	
	Fang.bounce = false
	
	if (control.player1.state & CONTROL_B)
	{
		if (Fang.coolDown >= 20)
			spawnCork()
	}
	
	if (control.player1.state & CONTROL_C) == false && (control.player1.state & CONTROL_B) == false
	{
// Start gliding
	char.flags &= ~(char.flag.ROLLING | char.flag.CONTROL_LOCK)
	char.hitbox_extends.y = 10
	char.hitbox_extends.x = 10
	char.double_jump_state = 1
	char.velocity.y += 0x200
	if (char.velocity.y < 0)
		char.velocity.y = 0

	char.groundspeed = 0x400
	if (char.flags & char.flag.FACING_LEFT)
	{
		char.velocity.x = -char.groundspeed
		knuckles.glide_direction = -0x80
	}
	else
	{
		char.velocity.x = char.groundspeed
		knuckles.glide_direction = 0
	}
	char.rotation.both = 0
	knuckles.glideclimbstate = 0x02

	fn016fa8()
	}
	else if ((control.player1.state & CONTROL_C) && (char.bonus_effect & char.bonus.SHIELD_FIRE) && !(char.bonus_effect & char.bonus.INVINCIBLE))
	{
		u8[0xffffcd08] = 1		// That's 0x20 inside the shield object at 0xffffcce8
		char.double_jump_state = 1

		s16 vx = 0x800
		if (char.flags & char.flag.FACING_LEFT)
			vx = -vx

		char.velocity.x = vx
		char.velocity.y = 0
		char.groundspeed = vx
		camera.locktime.player1 = 0x2000
		ClearPositionBackup()
		playSound(SFX_FIRESHIELDDASH)
	}
	else if ((control.player1.state & CONTROL_C) && (char.bonus_effect & char.bonus.SHIELD_LIGHTNING) && !(char.bonus_effect & char.bonus.INVINCIBLE))
	{
		u8[0xffffcd08] = 1
		char.double_jump_state = 1

		char.velocity.y = -0x580
		char.jumping = 0
		playSound(SFX_LIGHTNINGJUMP)
	}
	else if ((control.player1.state & CONTROL_C) && (char.bonus_effect & char.bonus.SHIELD_BUBBLE) && !(char.bonus_effect & char.bonus.INVINCIBLE))
	{
		u8[0xffffcd08] = 1
		char.double_jump_state = 1

	#if STANDALONE
		if (!Game.getSetting(SETTING_BUBBLE_SHIELD_BOUNCE))
	#endif
		{
			char.velocity.x = 0
		}

		char.velocity.y = 0x800
		char.groundspeed = 0
		playSound(SFX_BUBBLEBOUNCE)
	}
	else
	{
	#if STANDALONE
		// Knuckles in competition mode uses this code as well, but he should not have an insta-shield
		if (competition_mode.active && XtraChar == 3)
			return
	#else
		if (Character.performSuperTransformation())
			return
	#endif

		// Insta bubble-Shield
		if ((control.player1.state & CONTROL_C) && ((char.bonus_effect & char.bonus.ANY_SHIELD) == 0))
		{
			D1.s16 = s8(char.hitbox_extends.y - char.hitbox.default.y)
			char.double_jump_state = 1
			
			D1.s16 = -D1.s16
			
			Fang.bounce = true
			
			char.state = char.state.KNUX_STANDUP
			char.position.y.u16 += D1.s16
			char.hitbox_extends.x = char.hitbox.default.x
			char.hitbox_extends.y = char.hitbox.default.y
			char.velocity.y = 0x800
			char.groundspeed = 0
		
			playSound(0xa0)
		}
	}
}

function void Character.updateUprightOnGround()
{
	if (!competition_mode.active && (XtraChar != 3 || char.character != CHARACTER_KNUCKLES) || (competition_mode.active && char.character != 5))
	{
		base.Character.updateUprightOnGround()
		return
	}
	
	if (Character.UpdateSpindash())
		return

#if STANDALONE
	if (char.character == CHARACTER_SONIC && Game.getSetting(SETTING_SUPER_PEELOUT))
	{
		if (Character.updateSuperPeelout())
			return
	}
#endif

	if (control.player1.state & CONTROL_B)
	{
		if (Fang.coolDown >= 20)
			spawnCork()
	}

	if (control.pad1.pressed & CONTROL_C) || (control.pad1.pressed & CONTROL_A)
	{
		if (Character.CheckStartJump())
			return
	}

	Character.UpdateUprightSlopeEffect()
	Character.updateUprightOnGroundInner()
	Character.CheckForStartRolling()

	Character.sharedUpdateOnGround()
}

//# address-hook(0x00fe8e) end(0x00ff04)
function void Character.CheckCollisionsWithDynamicObjects()
{
	if (!competition_mode.active && (XtraChar != 3 || char.character != CHARACTER_KNUCKLES) || (competition_mode.active && char.character != 5))
	{
		base.Character.CheckCollisionsWithDynamicObjects()
		return
	}
	SonicUpdateRingCollection()
	UpdateShieldDeflecting()

	bool hasInstaShield = false
	if ((char.bonus_effect & 0x73) == 0)
	{
		hasInstaShield = (char.double_jump_state == 1)
	}

	if (hasInstaShield)
	{
		// Insta bubble-Shield makes Fang briefly invincible and increases his hitbox
		u8 oldBonusEffect = char.bonus_effect
		char.bonus_effect |= char.bonus.INVINCIBLE
	#if STANDALONE
		// Also make Insta bubble-Shield bounce off projectiles
		char.bonus_effect |= char.bonus.ANY_SHIELD
	#endif

		D2.u16 = char.position.x.u16 - 0x18
		D3.u16 = char.position.y.u16 - 0x18
		D4.u16 = 0x30
		D5.u16 = 0x30
		Character.CheckCollisionsWithDynamicObjects_partial()

		char.bonus_effect = oldBonusEffect
	}
	else
	{
		D5 = char.hitbox_extends.y - 3
		D2 = char.position.x.u16 - 8
		D3 = char.position.y.u16 - D5.u16
		D4 = 16
		D5 *= 2
		Character.CheckCollisionsWithDynamicObjects_partial()
	}
}

function void Character.LandingOnGroundResetState()
{
	if (!competition_mode.active && (XtraChar != 3 || char.character != CHARACTER_KNUCKLES) || (competition_mode.active && char.character != 5))
	{
		base.Character.LandingOnGroundResetState()
		return
	}
	
	char.flags &= ~char.flag.IN_AIR
	char.flags &= ~char.flag.PUSHING
	char.flags &= ~char.flag.CONTROL_LOCK
	char.jumping = 0
	score.bonus_counter = 0		// No more increasing bonusses after hitting the ground
	char.rotation.x = 0
	u8[A0 + 0x2d] = 0
	u8[A0 + 0x30] = 0
	char.look_up_down_timer = 0

	// Check for double jump state
	if (char.double_jump_state != 0)
	{
		if (Fang.bounce && (char.bonus_effect & char.bonus.ANY_SHIELD) == 0)
		{
			FangTailBounce()
		}
		else if (char.bonus_effect & char.bonus.SHIELD_BUBBLE)
		{
			if( (char.bonus_effect & char.bonus.INVINCIBLE) == 0)
			{
				SonicLandingBubbleBounce()
			}
		}
		
		char.double_jump_state = 0
	}
	
	if (control.player1.state & CONTROL_A) && (char.state >= 0x20)
	{
		char.state = char.state.KNUX_STANDUP
	}
}

function void FangTailBounce()
{
	s16 force = (char.flags & char.flag.UNDERWATER) ? 0x480 : 0x780

	s16 vx = mainchar.groundhit.velocity.x
	s16 vy = mainchar.groundhit.velocity.y
	u8 moveAngle = lookupAngleByVector(vx, vy)
	u8 groundAngle = char.rotation
	u8 reflectedAngle = groundAngle * 2 - moveAngle
	char.velocity.x = (s32(lookupCos(reflectedAngle)) * force) >> 8
	char.velocity.y = (s32(lookupSin(reflectedAngle)) * force) >> 8
	
	char.state = char.state.STRAIGHTJUMP
	char.flags |= (char.flag.IN_AIR | char.flag.ROLLING)
	char.jumping = 1
	char.on_convex_surface = 0
	char.hitbox_extends.y = 30
	char.hitbox_extends.x = 7

	s8 dy = char.hitbox_extends.y - char.hitbox.default.y
	char.position.y.u16 += (global.inv_gravity) ? dy : -dy

#if STANDALONE
	// Perform a ground collision check after updating the hitbox height
	//  -> This prevents getting killed when there's a blocker object right underneath
	Character.CheckFloorCollision()
	if (D1.s16 < 0)
	{
		char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16
	}
#endif

	playSound(0x87)
	Fang.bounce = false
}

//# address-hook(0x00ffd4) end(0x010214)
function void Character.OnCollisionWithDynamicObject()
{
	if (!competition_mode.active && (XtraChar != 3 || char.character != CHARACTER_KNUCKLES) || (competition_mode.active && char.character != 5))
	{
		base.Character.OnCollisionWithDynamicObject()
		return
	}
	
	// Example values for objA1.collision_attributes:
	//  - 0x06, 0x0b, 0x17, 0x1a = Different types of enemies
	//  - 0x0f		 = Boss enemy
	//  - 0x18		 = Extended arm of DEZ Chainspike
	//  - 0x23		 = AIZ Bloominator
	//  - 0x46		 = Monitor
	//  - 0x47		 = Dynamic ring
	//  - 0x87		 = Extended arm of SOZ Skorp
	//  - 0x8b, 0x9c = Flames, damaging parts of enemies
	//  - 0x8f		 = Wrecking ball
	//  - 0x98, 0x9b = Projectile
	//  - 0xd8		 = Thrown mushroom, stars over starpost

	D1.u8 = (objA1.collision_attributes & collision_attributes.flags)
	if (D1.u8 == 0)
	{
		// Collision is an enemy, i.e. is harmful, but can be attacked
		bool attacking = false
		if (char.bonus_effect & char.bonus.INVINCIBLE)
		{
			attacking = true
		}
		else if (char.state == char.state.ROLLING || char.state == char.state.SPINDASH)
		{
			attacking = true
		}
	#if STANDALONE
		else if (Game.getSetting(SETTING_DROPDASH) && char.character == CHARACTER_SONIC && char.state == char.state.SONIC_DROPDASH)
		{
			attacking = true
		}
	#endif

		if (!attacking)
		{
			bool isThreat = false
			if (char.character == CHARACTER_KNUCKLES)
			{
				isThreat = (char.double_jump_state != 1 && char.double_jump_state != 3)
			}
			else if (char.character == CHARACTER_SONIC || char.double_jump_state == 0 || (char.flags & char.flag.UNDERWATER))
			{
				isThreat = true
			}
			else
			{
				s16 dx = char.position.x.u16 - objA1.position.x.u16
				s16 dy = char.position.y.u16 - objA1.position.y.u16
				D0.u8 = lookupAngleByVector(dx, dy) - 0x20
				isThreat = (D0.u8 >= 0x40)
			}

			if (isThreat)
			{
				Character.OnThreatCollision()
				return
			}
		}

		if (u8[A1 + 0x29] != 0)
		{
			char.velocity.x = -char.velocity.x
			char.velocity.y = -char.velocity.y
			char.groundspeed = -char.groundspeed
			u8[A1 + 0x1c] = A0.u8
			u8[A1 + 0x25] = u8[A1 + 0x28]
			u8[A1 + 0x28] = 0
			--u8[A1 + 0x29]
			if (u8[A1 + 0x29] == 0)
			{
				u8[A1 + 0x2a] |= 0x80
			}
			char.double_jump_state = 0
			if (char.character == CHARACTER_KNUCKLES)
			{
				if (char.double_jump_state == 1)
				{
					char.double_jump_state = 2
					char.state = char.state.KNUX_FALLING

					if (char.velocity.x >= 0)
						char.flags |= char.flag.FACING_LEFT
					else
						char.flags &= ~char.flag.FACING_LEFT

					char.hitbox_extends.x = char.hitbox.default.x
					char.hitbox_extends.y = char.hitbox.default.y
				}
			}
		}
		else
		{
			if (u8[A1 + 0x2a] & 0x04)
			{
				A2 = 0xffff0000 + u16[A1 + 0x3c]
				u8[A2] &= ~(1 << u8[A1 + 0x3b])
			}

			u8[A1 + 0x2a] |= 0x80

			// Grant bonus points
			Enemy.addScore(A1, 0x010216)
			
			char.double_jump_state = 0

			objA1.update_address = 0x01e5e0
			u8[A1 + 0x05] = 0
			if (char.velocity.y < 0)
			{
				char.velocity.y += 0x100
			}
			else if (char.position.y.u16 >= objA1.position.y.u16)
			{
				char.velocity.y -= 0x100
			}
			else
			{
				char.velocity.y = -char.velocity.y
			}
		}
	}
	else if (D1.u8 == collision.flag.ITEM)
	{
		D0.u8 = (objA1.collision_attributes & collision_attributes.size)
		if (D0.u8 != collision.size.16x16)
		{
			// Collect ring, but only after 30 invulnerability frames
			//  -> Remember that the "char.invuln.countdown" timer starts at 120
			u8 timer = competition_mode.active ? char.invuln.countdown : u8[0xffffb000 + 0x34]
			if (timer < 90)
			{
				u8[A1 + 0x05] = 0x04
			}
		}
		else
		{
			// This part seems to be for monitors specifically
			s16 vy = (global.inv_gravity) ? -char.velocity.y : char.velocity.y
		#if STANDALONE
			// Calculate if the player is moving up, specifically relative to the monitor
			vy = char.velocity.y - objA1.velocity.y
		#endif
			bool movingUp = (objA1.render_flags & render_flag.FLIP_Y) ? (vy > 0) : (vy < 0)
		#if STANDALONE
			movingUp = (vy < 0)		// Velocity is normalised for inverted gravity anyway, so no need for fancy conditional checks

			// If player and monitor are at different orientations, check if player is moving down instead of up
			if ((objA1.render_flags & render_flag.FLIP_Y) != (char.render_flags & render_flag.FLIP_Y))
			{
				movingUp = !movingUp

				if (char.flags & char.flag.IN_AIR)
					objA1.flags2a &= ~object.flag.P1_PUSHING
			}

			movingUp = (movingUp && (abs(char.position.x.u16 - objA1.position.x.u16) < 0x12 || char.state == char.state.ROLLING))		// only bounce at a certain distance, otherwise push the player away when falling, #contributed by GFX32
		#endif
			if (movingUp)
			{
			#if STANDALONE
				if ((objA1.flags2a & object.flag.P1_PUSHING) && (char.flags & char.flag.IN_AIR))
				{
					// In S3AIR, do not allow S&K's monitor opening from the side
					//  -> This is done to be more consistent with other Sonic games, incl. Sonic 1, 2, CD, Mania and even Sonic 3 alone
					//  -> The first check above tells us if the character is on a side of the monitor
					//  -> The second one makes sure that you can always ground-based roll into a monitor (see e.g. first invincibility in MHZ 1, when spindashing into it from the right)
					return
				}
				else if (Game.getSetting(SETTING_MONITOR_BEHAVIOR) == 0)
				{
					// All you really need for Sonic & Knuckles monitor Behavior. everything else relevant is handled elsewhere
					char.velocity.y = -char.velocity.y
				}
				else
				{
					// Improved code to prevent crushing and allow bouncing on ground, #contributed by GFX32

					// If the player is below the monitor, it should bounce.
					bool isBelow = (char.position.y.u16 > (objA1.position.y.u16 + objA1.hitbox_extends.y))

					if (objA1.render_flags & render_flag.FLIP_Y)
						isBelow = (char.position.y.u16 < (objA1.position.y.u16 - objA1.hitbox_extends.y))

					// Not when spindashing!
					if (char.state == char.state.SPINDASH)
						isBelow = false

					if (isBelow)
					{
						// Hit monitor from below, make it fall
						u8[A1 + 0x3c] = 1

						char.velocity.y = -char.velocity.y
						objA1.velocity.y = -0x180

						// Calculate how far the monitor is inside the player, then separate them; this attempts to prevent crushing collision on subsequent frames.
						s16 dy = (objA1.position.y.u16 + objA1.hitbox_extends.y) - (char.position.y.u16 - char.hitbox_extends.y)

						if (objA1.render_flags & render_flag.FLIP_Y)
							dy = (objA1.position.y.u16 - objA1.hitbox_extends.y) - (char.position.y.u16 + char.hitbox_extends.y)

						// Only push the player when in midair
						if (char.flags & char.flag.IN_AIR)
						{
							dy /= 2
							char.position.y.u16 += dy
						}
						objA1.position.y.u16 -= dy

						if (u8[A1 + 0x3c] == 0)
							u8[A1 + 0x3c] = 4

						return
					}
				}
			#else
				if (objA1.flags2a & char.flag.IN_AIR)
				{
					// This block is a bit broken due to the above check, and falling monitors can crush the player, and is this really what we want?

					if ((objA1.render_flags & render_flag.FLIP_Y) == 0)
					{
						if (char.position.y.u16 - 0x10 < objA1.position.y.u16)
							return
					}
					else
					{
						if (char.position.y.u16 + 0x10 >= objA1.position.y.u16)
							return
					}

					char.velocity.y = -char.velocity.y
					objA1.velocity.y = -0x180
					if (u8[A1 + 0x3c] == 0)
						u8[A1 + 0x3c] = 4

					return
				}
			#endif
			}

			if (A0 != 0xffffb000 && competition_mode.active == 0)
			{
				// Sorry player 2, you can't open monitors in normal game
				return
			}

			bool canOpenMonitor = false
			if (char.state == char.state.ROLLING)
			{
				canOpenMonitor = true
			}
		#if STANDALONE
			else if (Game.getSetting(SETTING_DROPDASH) && char.character == CHARACTER_SONIC && char.state == char.state.SONIC_DROPDASH)
			{
				canOpenMonitor = true
			}
			else if (char.state == char.state.SPINDASH)
			{
				canOpenMonitor = true
			}
			else if (objA1.velocity.y < 0)
			{
				// Make monitors break over the player's head at different orientations. #contributed by Dynamic Lemons
				if ((global.inv_gravity != (objA1.render_flags & render_flag.FLIP_Y) != 0))
					canOpenMonitor = true
			}
		#endif
			else if (char.character == CHARACTER_KNUCKLES)
			{
				// Check if Knuckles glides into the monitor
				canOpenMonitor = (char.double_jump_state == 1 || char.double_jump_state == 3)
			}

			if (canOpenMonitor)
			{
			#if STANDALONE
				if (!movingUp)
			#endif
				{
					// Bounce off
					char.velocity.y = -char.velocity.y
				}
				
				char.double_jump_state = 0
				
				objA1.base_state = 0x04		// Set monitor state to broken
				objA1.monitor.character_address = A0.u16		// RAM address of character
			}
		}
	}
	else if (D1.u8 == collision.flag.THREAT)
	{
		// Harmful object
		Character.OnThreatCollision()
	}
	else  // D1.u8 == collision.flag.SPECIAL
	{
		// Other interactable object
		fn0103ba()
		Fang.bounce = false
	}
}

function void spawnCork()
{
	u32 A1backup = A1
	if (allocDynamicObjectStd())
	{
		Fang.coolDown = 0
		objA1.update_address = 0x212250
		objA1.render_flags = (render_flag.WORLD | render_flag.VISIBLE)
		objA1.sprite_priority = 0x100
		objA1.box_size.x = 0x18
		objA1.box_size.y = 0x18
		objA1.sprite_attributes = objA1.sprite_attributes
		objA1.position.y = objA0.position.y
		objA1.position.x = objA0.position.x
		objA1.velocity.x = (objA0.render_flags & render_flag.FLIP_X) ? -0x900 : 0x900
		objA1.position.x.u16 += (objA0.render_flags & render_flag.FLIP_X) ? -0x12 : 0x12
		objA1.hitbox_extends.x = 9
		objA1.hitbox_extends.y = 16
		objA1.value26 = 0
		if (objA1.velocity.x > 0)
		{
			objA1.render_flags |= render_flag.FLIP_X
		}
		//playSound(0x4d)
	}
	A1 = A1backup
}

//# address-hook(0x212260)
function void Cork.Explosion()
{
	A1 = 0x01e5e0
	objA0.update_address = A1
	objA0.base_state = 0x02
	call A1
	u8[A0 + 0x0a] |= 0x80
}
//# address-hook(0x212250)
function void Cork.BaseUpdate()
{
	if !(objA0.render_flags & render_flag.VISIBLE)
	{
		D5c = 0
		D2c = 0
		D3c = 0
		D4c = 0
		UnloadObject()
		return
	}
	
	if (objA0.value26 == 0)
	{
		objA0.value26 = 1
		spawnSimpleChildObjects(0x212260, 1)
	}
	
	UpdateMovementStraightSimple()
	DrawObject()
	
	D5c = objA0.hitbox_extends.y - 3
	D2c = objA0.position.x.u16 - 8
	D3c = objA0.position.y.u16 - D5c
	D4c = 16
	D5c *= 2
	
	D5 = objA0.hitbox_extends.y - 3
	D2 = objA0.position.x.u16 - 8
	D3 = objA0.position.y.u16 - D5.u16
	D4 = 16
	D5 *= 2
	CheckCollisonForCork()
}

global u16 D5c
global u16 D4c
global u16 D3c
global u16 D2c
function void CheckCollisonForCorkGlobal()
{
#if STANDALONE
	// Bounding box of cork
	if (DEBUG_DYNAMIC_COLLISIONS)
		debugDrawRect(D2c, D3c, D4c, D5c, 0x8000ff00)
#endif
	u16 numObjects = u16[0xffffe380]	// Actually it's twice the number of dynamic objects
	A4 = 0xffffe380 + 2
	while (numObjects != 0)
	{
		// Get address of dynamic object
		A1 = 0xffff0000 + u16[A4]
		A4 += 2

		// Offset into a list of hitbox sizes (the list looks a bit random)
		u16 offset = objA1.collision_attributes
		if (offset != 0)
		{
			// Targets:
			//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4
			//  - 0x14 x 0x14  -> (offset & collision_attributes.size) = collision.size.20x20
			//  - 0x0c x 0x14  -> (offset & collision_attributes.size) = collision.size.12x20
			//  - 0x14 x 0x0c  -> (offset & collision_attributes.size) = collision.size.20x12
			//  - 0x04 x 0x10  -> (offset & collision_attributes.size) = collision.size.4x16
			//  - 0x0c x 0x12  -> (offset & collision_attributes.size) = collision.size.12x18
			//  - 0x10 x 0x10  -> (offset & collision_attributes.size) = collision.size.16x16
			//  - 0x06 x 0x06  -> (offset & collision_attributes.size) = collision.size.6x6
			//  - 0x18 x 0x0c  -> (offset & collision_attributes.size) = collision.size.24x12
			//  - 0x0c x 0x10  -> (offset & collision_attributes.size) = collision.size.12x16
			//  - 0x10 x 0x08  -> (offset & collision_attributes.size) = collision.size.16x8
			//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8
			//  - 0x14 x 0x10  -> (offset & collision_attributes.size) = collision.size.20x16
			//  - 0x14 x 0x08  -> (offset & collision_attributes.size) = collision.size.20x8
			//  - 0x0e x 0x0e  -> (offset & collision_attributes.size) = collision.size.14x14
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24
			//  - 0x28 x 0x10  -> (offset & collision_attributes.size) = collision.size.40x16
			//  - 0x10 x 0x18  -> (offset & collision_attributes.size) = collision.size.16x24
			//  - 0x08 x 0x10  -> (offset & collision_attributes.size) = collision.size.8x16
			//  - 0x20 x 0x70  -> (offset & collision_attributes.size) = collision.size.32x112
			//  - 0x40 x 0x20  -> (offset & collision_attributes.size) = collision.size.64x32
			//  - 0x80 x 0x20  -> (offset & collision_attributes.size) = collision.size.128x32
			//  - 0x20 x 0x20  -> (offset & collision_attributes.size) = collision.size.32x32
			//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8_2
			//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4_2
			//  - 0x20 x 0x08  -> (offset & collision_attributes.size) = collision.size.32x8
			//  - 0x0c x 0x0c  -> (offset & collision_attributes.size) = collision.size.12x12
			//  - 0x08 x 0x04  -> (offset & collision_attributes.size) = collision.size.8x4
			//  - 0x18 x 0x04  -> (offset & collision_attributes.size) = collision.size.24x4
			//  - 0x28 x 0x04  -> (offset & collision_attributes.size) = collision.size.40x4
			//  - 0x04 x 0x08  -> (offset & collision_attributes.size) = collision.size.4x8
			//  - 0x04 x 0x18  -> (offset & collision_attributes.size) = collision.size.4x24
			//  - 0x04 x 0x28  -> (offset & collision_attributes.size) = collision.size.4x40
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_2
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_3
			//  - 0x0c x 0x18  -> (offset & collision_attributes.size) = collision.size.12x24
			//  - 0x48 x 0x08  -> (offset & collision_attributes.size) = collision.size.72x8
			//  - 0x18 x 0x28  -> (offset & collision_attributes.size) = collision.size.24x40
			//  - 0x10 x 0x04  -> (offset & collision_attributes.size) = collision.size.16x4
			//  - 0x20 x 0x02  -> (offset & collision_attributes.size) = collision.size.32x2
			//  - 0x10 x 0x1c  -> (offset & collision_attributes.size) = collision.size.16x28
			//  - 0x0c x 0x24  -> (offset & collision_attributes.size) = collision.size.12x36
			//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2
			//  - 0x04 x 0x40  -> (offset & collision_attributes.size) = collision.size.4x64
			//  - 0x18 x 0x40  -> (offset & collision_attributes.size) = collision.size.24x64
			//  - 0x20 x 0x10  -> (offset & collision_attributes.size) = collision.size.32x16
			//  - 0x1c x 0x14  -> (offset & collision_attributes.size) = collision.size.28x20
			//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2_2
			//  - 0x10 x 0x01  -> (offset & collision_attributes.size) = collision.size.16x1
			//  - 0x02 x 0x08  -> (offset & collision_attributes.size) = collision.size.2x8
			//  - 0x10 x 0x40  -> (offset & collision_attributes.size) = collision.size.16x64
			//  - 0x0c x 0x04  -> (offset & collision_attributes.size) = collision.size.12x4
			//  - 0x08 x 0x0c  -> (offset & collision_attributes.size) = collision.size.8x12
			//  - 0x28 x 0x20  -> (offset & collision_attributes.size) = collision.size.40x32
			//  - 0x40 x 0x02  -> (offset & collision_attributes.size) = collision.size.64x2
			//  - 0x60 x 0x02  -> (offset & collision_attributes.size) = collision.size.96x2
			//  - 0x28 x 0x28  -> (offset & collision_attributes.size) = collision.size.40x40
			A2 = 0x00ff62 + (offset & collision_attributes.size) * 2
			s16 hitbox.x = u8[A2]
			s16 hitbox.y = u8[A2+1]

			u16 px = objA1.position.x.u16 - hitbox.x
			u16 py = objA1.position.y.u16 - hitbox.y
			u16 sx = hitbox.x * 2
			u16 sy = hitbox.y * 2

		#if STANDALONE
			if (DEBUG_DYNAMIC_COLLISIONS)
			{
				if ((offset & collision_attributes.flags) == collision.flag.ITEM)
					debugDrawRect(px, py, sx, sy, 0x8000ff00)
				else if ((offset & collision_attributes.flags) == collision.flag.SPECIAL)
					debugDrawRect(px, py, sx, sy, 0x80ff0000)
				else if ((offset & collision_attributes.flags) == collision.flag.THREAT)
					debugDrawRect(px, py, sx, sy, 0x800000ff)
				else
					debugDrawRect(px, py, sx, sy, 0x80ff00ff)
			}
		#endif

			if (checkBoxOverlap(D2c, D3c, D4c, D5c, px, py, sx, sy))
			{
				// Collision found
				OnCollision()
				return
			}
		}

		numObjects -= 2
	}
}

function void CheckCollisonForCork()
{
#if STANDALONE
	// Bounding box of cork
	if (DEBUG_DYNAMIC_COLLISIONS)
		debugDrawRect(D2.u16, D3.u16, D4.u16, D5.u16, 0x8000ff00)
#endif
	u16 numObjects = u16[0xffffe380] * 2	// Actually it's twice the number of dynamic objects
	A4 = 0xffffe380 + 2
	while (numObjects != 0)
	{
		// Get address of dynamic object
		A1 = 0xffff0000 + u16[A4]
		A4 += 2

		// Offset into a list of hitbox sizes (the list looks a bit random)
		u16 offset = objA1.collision_attributes
		if (offset != 0)
		{
			// Targets:
			//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4
			//  - 0x14 x 0x14  -> (offset & collision_attributes.size) = collision.size.20x20
			//  - 0x0c x 0x14  -> (offset & collision_attributes.size) = collision.size.12x20
			//  - 0x14 x 0x0c  -> (offset & collision_attributes.size) = collision.size.20x12
			//  - 0x04 x 0x10  -> (offset & collision_attributes.size) = collision.size.4x16
			//  - 0x0c x 0x12  -> (offset & collision_attributes.size) = collision.size.12x18
			//  - 0x10 x 0x10  -> (offset & collision_attributes.size) = collision.size.16x16
			//  - 0x06 x 0x06  -> (offset & collision_attributes.size) = collision.size.6x6
			//  - 0x18 x 0x0c  -> (offset & collision_attributes.size) = collision.size.24x12
			//  - 0x0c x 0x10  -> (offset & collision_attributes.size) = collision.size.12x16
			//  - 0x10 x 0x08  -> (offset & collision_attributes.size) = collision.size.16x8
			//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8
			//  - 0x14 x 0x10  -> (offset & collision_attributes.size) = collision.size.20x16
			//  - 0x14 x 0x08  -> (offset & collision_attributes.size) = collision.size.20x8
			//  - 0x0e x 0x0e  -> (offset & collision_attributes.size) = collision.size.14x14
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24
			//  - 0x28 x 0x10  -> (offset & collision_attributes.size) = collision.size.40x16
			//  - 0x10 x 0x18  -> (offset & collision_attributes.size) = collision.size.16x24
			//  - 0x08 x 0x10  -> (offset & collision_attributes.size) = collision.size.8x16
			//  - 0x20 x 0x70  -> (offset & collision_attributes.size) = collision.size.32x112
			//  - 0x40 x 0x20  -> (offset & collision_attributes.size) = collision.size.64x32
			//  - 0x80 x 0x20  -> (offset & collision_attributes.size) = collision.size.128x32
			//  - 0x20 x 0x20  -> (offset & collision_attributes.size) = collision.size.32x32
			//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8_2
			//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4_2
			//  - 0x20 x 0x08  -> (offset & collision_attributes.size) = collision.size.32x8
			//  - 0x0c x 0x0c  -> (offset & collision_attributes.size) = collision.size.12x12
			//  - 0x08 x 0x04  -> (offset & collision_attributes.size) = collision.size.8x4
			//  - 0x18 x 0x04  -> (offset & collision_attributes.size) = collision.size.24x4
			//  - 0x28 x 0x04  -> (offset & collision_attributes.size) = collision.size.40x4
			//  - 0x04 x 0x08  -> (offset & collision_attributes.size) = collision.size.4x8
			//  - 0x04 x 0x18  -> (offset & collision_attributes.size) = collision.size.4x24
			//  - 0x04 x 0x28  -> (offset & collision_attributes.size) = collision.size.4x40
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_2
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_3
			//  - 0x0c x 0x18  -> (offset & collision_attributes.size) = collision.size.12x24
			//  - 0x48 x 0x08  -> (offset & collision_attributes.size) = collision.size.72x8
			//  - 0x18 x 0x28  -> (offset & collision_attributes.size) = collision.size.24x40
			//  - 0x10 x 0x04  -> (offset & collision_attributes.size) = collision.size.16x4
			//  - 0x20 x 0x02  -> (offset & collision_attributes.size) = collision.size.32x2
			//  - 0x10 x 0x1c  -> (offset & collision_attributes.size) = collision.size.16x28
			//  - 0x0c x 0x24  -> (offset & collision_attributes.size) = collision.size.12x36
			//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2
			//  - 0x04 x 0x40  -> (offset & collision_attributes.size) = collision.size.4x64
			//  - 0x18 x 0x40  -> (offset & collision_attributes.size) = collision.size.24x64
			//  - 0x20 x 0x10  -> (offset & collision_attributes.size) = collision.size.32x16
			//  - 0x1c x 0x14  -> (offset & collision_attributes.size) = collision.size.28x20
			//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2_2
			//  - 0x10 x 0x01  -> (offset & collision_attributes.size) = collision.size.16x1
			//  - 0x02 x 0x08  -> (offset & collision_attributes.size) = collision.size.2x8
			//  - 0x10 x 0x40  -> (offset & collision_attributes.size) = collision.size.16x64
			//  - 0x0c x 0x04  -> (offset & collision_attributes.size) = collision.size.12x4
			//  - 0x08 x 0x0c  -> (offset & collision_attributes.size) = collision.size.8x12
			//  - 0x28 x 0x20  -> (offset & collision_attributes.size) = collision.size.40x32
			//  - 0x40 x 0x02  -> (offset & collision_attributes.size) = collision.size.64x2
			//  - 0x60 x 0x02  -> (offset & collision_attributes.size) = collision.size.96x2
			//  - 0x28 x 0x28  -> (offset & collision_attributes.size) = collision.size.40x40
			A2 = 0x00ff62 + (offset & collision_attributes.size) * 2
			s16 hitbox.x = u8[A2]
			s16 hitbox.y = u8[A2+1]

			u16 px = objA1.position.x.u16 - hitbox.x
			u16 py = objA1.position.y.u16 - hitbox.y
			u16 sx = hitbox.x * 2
			u16 sy = hitbox.y * 2

		#if STANDALONE
			if (DEBUG_DYNAMIC_COLLISIONS)
			{
				if ((offset & collision_attributes.flags) == collision.flag.ITEM)
					debugDrawRect(px, py, sx, sy, 0x8000ff00)
				else if ((offset & collision_attributes.flags) == collision.flag.SPECIAL)
					debugDrawRect(px, py, sx, sy, 0x80ff0000)
				else if ((offset & collision_attributes.flags) == collision.flag.THREAT)
					debugDrawRect(px, py, sx, sy, 0x800000ff)
				else
					debugDrawRect(px, py, sx, sy, 0x80ff00ff)
			}
		#endif

			if (checkBoxOverlap(D2.u16, D3.u16, D4.u16, D5.u16, px, py, sx, sy))
			{
				// Collision found
				OnCollision()
				return
			}
		}

		numObjects -= 2
	}
}

//what to do if collison with object is found
function void OnCollision()
{
	// Example values for objA1.collision_attributes:
	//  - 0x06, 0x0b, 0x17, 0x1a = Different types of enemies
	//  - 0x0f		 = Boss enemy
	//  - 0x18		 = Extended arm of DEZ Chainspike
	//  - 0x23		 = AIZ Bloominator
	//  - 0x46		 = Monitor
	//  - 0x47		 = Dynamic ring
	//  - 0x87		 = Extended arm of SOZ Skorp
	//  - 0x8b, 0x9c = Flames, damaging parts of enemies
	//  - 0x8f		 = Wrecking ball
	//  - 0x98, 0x9b = Projectile
	//  - 0xd8		 = Thrown mushroom, stars over starpost

	D1.u8 = (objA1.collision_attributes & collision_attributes.flags)
	if (D1.u8 == 0)
	{
		if (u8[A1 + 0x29] != 0)
		{
			u8[A1 + 0x1c] = A0.u8
			u8[A1 + 0x25] = u8[A1 + 0x28]
			u8[A1 + 0x28] = 0
			--u8[A1 + 0x29]
			if (u8[A1 + 0x29] == 0)
			{
				u8[A1 + 0x2a] |= 0x80
			}
		}
		else
		{
			if (u8[A1 + 0x2a] & 0x04)
			{
				A2 = 0xffff0000 + u16[A1 + 0x3c]
				u8[A2] &= ~(1 << u8[A1 + 0x3b])
			}

			u8[A1 + 0x2a] |= 0x80

			// Grant bonus points
			Enemy.addScore(A1, 0x010216)

			objA1.update_address = 0x01e5e0
			u8[A1 + 0x05] = 0
		}
	}
	else if (D1.u8 == collision.flag.ITEM)
	{
		D0.u8 = (objA1.collision_attributes & collision_attributes.size)
		if (D0.u8 == collision.size.16x16)
		{
			u32 A0backup = A0
			A0 = 0xffffb000
			objA1.base_state = 0x04		// Set monitor state to broken
			objA1.monitor.character_address = A0.u16		// RAM address of character
			A0 = A0backup
		}
	}
}

//# address-hook(0x016890) end(0x016c78)
//# translated(0x016f6c) end(0x016fa6)
function void UpdateKnucklesGlideCollision()
{
	if (!competition_mode.active && (XtraChar != 3 || char.character != CHARACTER_KNUCKLES) || (competition_mode.active && char.character != 5))
	{
		base.UpdateKnucklesGlideCollision()
		return
	}
	if (char.double_jump_state == 0)
		return

	D0.u8 = char.double_jump_state
	if (char.double_jump_state == 1 || char.double_jump_state > 5)	// Last check is probably not needed, just added for full compatibility
	{
		// Gliding state
		fn01793e()
		if (knuckles.glideclimbstate & 0x02)	// Gliding?
		{
			if (knuckles.glideclimbstate & 0x20)	// Climbing?
			{
				if ((knuckles.preventclimbing & 0x80) == 0)
				{
					bool hit_wall = true
					D5.u8 = char.layer_flags2
					D0.u8 = knuckles.glide_direction + 0x40
					if (D0.s8 < 0)
					{
						char.flags |= char.flag.FACING_LEFT & (char.character == CHARACTER_KNUCKLES &&(control.player1.state & CONTROL_LEFT & CONTROL_RIGHT) == 1)
						fn00fcca()

						D1.u16 |= D0.u16
						if (D1.u16 != 0)
						{
							D3.u16 = char.position.x.u16 - s8(char.hitbox_extends.y) - 1

							if (global.inv_gravity == 0)
							{
								D2.u16 = char.position.y.u16 - 11
								fn00f8a6()
								if (D1.s16 < 0 || D1.u16 >= 12)
								{
									hit_wall = false
								}
								else
								{
									char.position.y.u16 += D1.u16
								}
							}
							else
							{
								D2.u16 = (char.position.y.u16 + 11) ^ 0x0f
								fn00fc5c()
								if (D1.s16 < 0 || D1.u16 >= 12)
								{
									hit_wall = false
								}
								else
								{
									char.position.y.u16 -= D1.u16
								}
							}
						}
						else
						{
							++char.position.x.u16
						}
					}
					else
					{
						char.flags &= ~char.flag.FACING_LEFT
						fn00f9ba()

						D1.u16 |= D0.u16
						if (D1.u16 != 0)
						{
							D3.u16 = char.position.x.u16 + s8(char.hitbox_extends.y) + 1

							if (global.inv_gravity == 0)
							{
								D2.u16 = char.position.y.u16 - 11
								fn00f8a6()
								if (D1.s16 < 0 || D1.u16 >= 12)
								{
									hit_wall = false
								}
								else
								{
									char.position.y.u16 += D1.u16
								}
							}
							else
							{
								D2.u16 = (char.position.y.u16 + 11) ^ 0x0f
								fn00fc5c()
								if (D1.s16 < 0 || D1.u16 >= 12)
								{
									hit_wall = false
								}
								else
								{
									char.position.y.u16 -= D1.u16
								}
							}
						}
					}

					if (hit_wall)
					{
						// When Hyper Knuckles hits a wall fast enough, that kills all badniks on screen
						if ((super.active & 0x80) && u16(char.groundspeed) >= 0x480)
						{
							camera.hyper_knux_shake = 0x14
							Character.ClearEnemiesOnScreen()
							playSound(0x49)
						}
						else
						{
							playSound(SFX_GRAB)
						}

						char.groundspeed = 0
						char.velocity.x = 0
						char.velocity.y = 0
						char.double_jump_state = 4
						char.animation.sprite = 0xb7
						char.animation.timer = 0x7f
						char.animation.frame = 0
						knuckles.glide_direction = 3
						u16[A0 + 0x12] = char.position.x.u16
						return
					}
				}

				char.double_jump_state = 2
				char.state = char.state.KNUX_FALLING
				char.hitbox_extends.x = char.hitbox.default.x
				char.hitbox_extends.y = char.hitbox.default.y
				knuckles.glideclimbstate |= 0x02
				return
			}

			if (control.player1.state & CONTROL_C)
			{
				fn016fa8()
			}
			else
			{
				// Stop gliding
				char.double_jump_state = 0
				char.state = char.state.KNUX_FALLING
				if (char.velocity.x < 0)
					char.flags |= char.flag.FACING_LEFT
				else
					char.flags &= ~char.flag.FACING_LEFT

				char.velocity.x >>= 2
				char.hitbox_extends.x = char.hitbox.default.x
				char.hitbox_extends.y = char.hitbox.default.y

			#if STANDALONE
				// Perform a ground collision check after updating the hitbox height
				//  -> This prevents getting killed when Knuckles stops gliding just above the floor and there's a blocker object right underneath
				Character.CheckFloorCollision()
				if (D1.s16 < 0)
				{
					char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16
				}
			#endif
			}
		}
		else
		{
			if (char.velocity.x < 0)
				char.flags |= char.flag.FACING_LEFT
			else
				char.flags &= ~char.flag.FACING_LEFT

			D0.u8 = (char.rotation + 0x20) & 0xc0
			if (D0.u8 != 0)
			{
				char.velocity.x = char.groundspeed
				char.velocity.y = 0
				Character.LandingOnGroundNoSpindash()
			}
			else
			{
				char.double_jump_state = 3
				char.animation.sprite = 0xcc
				char.animation.timer = 0x7f
				char.animation.frame = 0
				if (char.drown_countdown >= 12)
				{
					u8[A6 + 0x05] = 6
					u8[A6 + 0x22] = 0x15
				}
			}
		}
	}
	else if (char.double_jump_state == 2)
	{
		// Falling state
		Character.UpdateControlInAir()

		// Gravity
		char.velocity.y += (char.flags & char.flag.UNDERWATER) ? 0x10 : 0x38

		fn01793e()
		if ((knuckles.glideclimbstate & 0x02) == 0)
		{
			char.groundspeed = 0
			char.velocity.x = 0
			char.velocity.y = 0
			s16 dy = s8(char.hitbox_extends.y - char.hitbox.default.y)
			char.position.y.u16 += global.inv_gravity ? -dy : dy
			playSound(0x4c)

			D0.u8 = (char.rotation + 0x20) & 0xc0
			if (D0.u8 != 0)
			{
				Character.LandingOnGroundNoSpindash()
			}
			else
			{
				Character.LandingOnGroundNoSpindash()
				char.hlock_countdown = 15
				char.state = char.state.KNUX_STANDUP2
			}
		}
	}
	else if (char.double_jump_state == 3)
	{
		// Touched ground while gliding
		bool goto016b64 = false
		if (control.player1.state & CONTROL_C)
		{
			if (char.velocity.x < 0)
			{
				char.velocity.x += 0x20
				goto016b64 = (char.velocity.x < 0)
			}
			else
			{
				char.velocity.x -= 0x20
				goto016b64 = (char.velocity.x >= 0)
			}
		}

		if (goto016b64)
		{
			fn01793e()
			Character.CheckFloorCollision()
			if (D1.s16 < 0x0e)
			{
				char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16
				char.rotation = D3.u8
				if ((level.framecounter.low & 0x07) == 0)
				{
					playSound(0x7e)
				}
			}
			else
			{
				char.double_jump_state = 2
				char.state = char.state.KNUX_FALLING
				char.hitbox_extends.x = char.hitbox.default.x
				char.hitbox_extends.y = char.hitbox.default.y
				knuckles.glideclimbstate |= 0x02
			}
		}
		else
		{
			char.groundspeed = 0
			char.velocity.x = 0
			char.velocity.y = 0
			s16 dy = s8(char.hitbox_extends.y - char.hitbox.default.y)
			char.position.y.u16 += global.inv_gravity ? -dy : dy
			Character.LandingOnGroundNoSpindash()
			char.hlock_countdown = 15
			char.state = char.state.KNUX_STANDUP2
		}
	}
	else if (char.double_jump_state == 4)
	{
		// Climbing state
		if (knuckles.preventclimbing & 0x80 || char.position.x.u16 != u16[A0 + 0x12] || (char.flags & char.flag.ON_OBJECT))
		{
			fn016ed2()
			return
		}

		char.groundspeed = 0
		char.velocity.x = 0
		char.velocity.y = 0
		u32[0xfffff796] = (char.layer_flags2 == 0x0d) ? u32[0xfffff7b4] : u32[0xfffff7b8]
		D5.u8 = char.layer_flags2
		D1 = 0

		if ((control.player1.state & CONTROL_UP) == 0)
		{
			fn016d10()
			return
		}

		if (global.inv_gravity)
		{
			fn016da8()
			return
		}

		D2.u16 = char.position.y.u16 - 11
		fn016f4e()
		if (D1.s16 >= 4)
		{
			fn016eba()
			return
		}

		if (D1.u16 != 0)
		{
			fn016e60()
		}

		D5.u8 = char.layer_flags2
		D2.u16 = char.position.y.u16 - 8
		D3.u16 = char.position.x.u16
		fn00fbee()
		if (D1.s16 < 0)
		{
			char.position.y.u16 -= D1.u16
			D1 = 1
		}
		else
		{
			--char.position.y.u16
			if (super.active)
				--char.position.y.u16

			D1 = 1
			D0.u16 = level.vertical_wrap
			if (D0.u16 != 0xff00)
			{
				D0.u16 += 0x10
				if (D0.s16 > s16(objA0.position.y.u16))
				{
					char.position.y.u16 = D0.u16
				}
			}
		}
		fn016e10()
	}
	else if (char.double_jump_state == 5)
	{
		// Climbing up a ledge
		if (char.animation.timer == 0)
		{
			fn016efe()
			if (knuckles.glide_direction == 0x10)
			{
				char.groundspeed = 0
				char.velocity.x = 0
				char.velocity.y = 0
				if (char.flags & char.flag.FACING_LEFT)
					--char.position.x.u16

				Character.LandingOnGroundNoSpindash()
				char.state = char.state.STANDING
			}
		}
	}
}
